"use strict";(self.webpackChunkshell=self.webpackChunkshell||[]).push([[460],{9079:(R,v,l)=>{l.r(v),l.d(v,{outputFromObservable:()=>m,outputToObservable:()=>p,pendingUntilEvent:()=>g,rxResource:()=>D,takeUntilDestroyed:()=>b,toObservable:()=>f,toSignal:()=>y,\u0275toObservableMicrotask:()=>h});var e=l(4381),d=l(4866),j=l(2778);function b(r){r||((0,e.assertInInjectionContext)(b),r=(0,e.inject)(e.DestroyRef));const t=new d.Observable(n=>r.onDestroy(n.next.bind(n)));return n=>n.pipe((0,j.takeUntil)(t))}class O{source;destroyed=!1;destroyRef=(0,e.inject)(e.DestroyRef);constructor(t){this.source=t,this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(t){if(this.destroyed)throw new e.\u0275RuntimeError(953,!1);const n=this.source.pipe(b(this.destroyRef)).subscribe({next:o=>t(o)});return{unsubscribe:()=>n.unsubscribe()}}}function m(r,t){return new O(r)}function p(r){const t=(0,e.\u0275getOutputDestroyRef)(r);return new d.Observable(n=>{t?.onDestroy(()=>n.complete());const o=r.subscribe(c=>n.next(c));return()=>o.unsubscribe()})}function f(r,t){!t?.injector&&(0,e.assertInInjectionContext)(f);const n=t?.injector??(0,e.inject)(e.Injector),o=new d.ReplaySubject(1),c=(0,e.effect)(()=>{let s;try{s=r()}catch(i){return void(0,e.untracked)(()=>o.error(i))}(0,e.untracked)(()=>o.next(s))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{c.destroy(),o.complete()}),o.asObservable()}function h(r,t){!t?.injector&&(0,e.assertInInjectionContext)(f);const n=t?.injector??(0,e.inject)(e.Injector),o=new d.ReplaySubject(1),c=(0,e.\u0275microtaskEffect)(()=>{let s;try{s=r()}catch(i){return void(0,e.untracked)(()=>o.error(i))}(0,e.untracked)(()=>o.next(s))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{c.destroy(),o.complete()}),o.asObservable()}function y(r,t){const n=!t?.manualCleanup;n&&!t?.injector&&(0,e.assertInInjectionContext)(y);const o=n?t?.injector?.get(e.DestroyRef)??(0,e.inject)(e.DestroyRef):null,c=function E(r=Object.is){return(t,n)=>1===t.kind&&1===n.kind&&r(t.value,n.value)}(t?.equal);let s;s=(0,e.signal)(t?.requireSync?{kind:0}:{kind:1,value:t?.initialValue},{equal:c});const i=r.subscribe({next:u=>s.set({kind:1,value:u}),error:u=>{if(t?.rejectErrors)throw u;s.set({kind:2,error:u})}});if(t?.requireSync&&0===s().kind)throw new e.\u0275RuntimeError(601,!1);return o?.onDestroy(i.unsubscribe.bind(i)),(0,e.computed)(()=>{const u=s();switch(u.kind){case 1:return u.value;case 2:throw u.error;case 0:throw new e.\u0275RuntimeError(601,!1)}},{equal:t?.equal})}function g(r){void 0===r&&((0,e.assertInInjectionContext)(g),r=(0,e.inject)(e.Injector));const t=r.get(e.PendingTasks);return n=>new d.Observable(o=>{const c=t.add();let s=!1;function i(){s||(c(),s=!0)}const u=n.subscribe({next:a=>{o.next(a),i()},complete:()=>{o.complete(),i()},error:a=>{o.error(a),i()}});return u.add(()=>{o.unsubscribe(),i()}),u})}function D(r){return r?.injector||(0,e.assertInInjectionContext)(D),(0,e.resource)({...r,loader:void 0,stream:t=>{let n;const o=()=>n.unsubscribe();t.abortSignal.addEventListener("abort",o);const c=(0,e.signal)({value:void 0});let s;const i=new Promise(a=>s=a);function u(a){c.set(a),s?.(c),s=void 0}return n=r.loader(t).subscribe({next:a=>u({value:a}),error:a=>u({error:a}),complete:()=>{s&&u({error:new Error("Resource completed before producing a value")}),t.abortSignal.removeEventListener("abort",o)}}),i}})}}}]);